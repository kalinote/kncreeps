# 基于任务驱动的行为系统设计

## 0. 原始需求说明

原有的角色行为(behaviors)设计是按照不同角色的各种操作通过代码写死的，无法动态地、灵活地安排和执行任务。
比如，目前搬运工是固定地从地上拾取资源，放到spawn中，如果后续需要在不同的建筑，或者不同的来源和目标之间运送不同种类的资源，就需要大量重写其逻辑。

基于上述问题，决定对系统重构，增加任务系统。

基于任务系统的设计，所有role都应该是基于任务而执行的，而不是通过代码写死其逻辑。比如目前的矿工(hervester)有两套逻辑，分别是通用矿工(挖矿->将矿物送回spawn->返回挖矿)和专业挖矿(挖矿->将资源丢到地上->继续挖矿)，使用上述任务系统，就可以将这些行为定义成不同的任务，而不需要写死在代码中了，同样如果后续有新的行为添加(比如某种情况下，需要临时将某一个矿工的职能改成搬运工，因为矿工也有MOVE和CARRY部件)只需要下发任务就可以进行其职能行为的切换

一个creep不需要知道其是处于"混合模式"还是"专业模式"，甚至HarvestTask都不应该拥有多种模式，因为：我之所以想添加这个任务系统，就是因为我想把行为从角色和中分离出来，creep只需要专注于它下一步应该干什么。同样的，我认为也不应该有什么"紧急运输"之类的特殊任务，而是在调度时直接给creep分配一个运输的任务，此时这个creep就应该是transporter。引入任务系统后，应该弱化职业和具体某一个creep的深度绑定(比如现在每个creep都绑定了一个职业)，而是将职业和任务联系起来，每种职业应该干哪些任务，同时职业又和creep的能力联系起来，比如某个creep有WORK、MOVE、CARRY组件，那么它可以是harvester(要求WORK、MOVE、CARRY)，也可以是transporter(MOVE、CARRY)，也可以是upgrader(要求WORK、MOVE、CARRY)，每个creep可以有一种职业，但不需要和职业强绑定。同时在根据能力匹配职业时，应该优先考虑匹配度更高的，比如一个creep有WORK、MOVE、CARRY组件，同时有两个任务空缺，分别是升级任务(需求WORK、MOVE、CARRY)和搬运任务(要求MOVE、CARRY)，此时应该优先将其分配到升级任务中(假设在优先级相同的情况下)。每个任务默认为"正常"优先度，"紧急"优先度的任务应该优先被执行(即便是其能力匹配度更低)，关于这一点还需要更详细的设计。

## 1. 系统概述

### 1.1 设计目标

将现有的硬编码行为系统重构为基于任务驱动的灵活系统，实现以下目标：

- **解耦行为与角色**：将具体行为从角色定义中分离
- **动态任务分配**：根据creep能力和任务需求动态分配任务
- **提高灵活性**：支持复杂场景如从 建筑A 到 建筑B 的运输
- **简化维护**：去除复杂的模式判断，简化代码逻辑
- **增强可扩展性**：新增任务类型无需修改现有角色逻辑

### 1.2 核心设计理念

- **任务驱动**：creep只关注当前任务，不关心执行模式
- **能力导向**：基于creep的实际能力分配任务
- **动态角色**：角色可以根据任务动态调整
- **状态机管理**：任务内部使用状态机管理执行过程

## 2. 系统架构设计

### 2.1 整体架构

```
Task-Driven System
├── Task System (任务系统)
│   ├── Task Definition (任务定义)
│   ├── Task Manager (任务管理器)
│   └── Task Executor (任务执行器)
├── Role System (角色系统)
│   ├── Role Assignment (角色分配)
│   ├── Capability Matching (能力匹配)
│   └── Dynamic Role Management (动态角色管理)
├── Scheduler System (调度系统)
│   ├── Task Scheduler (任务调度器)
│   ├── Creep Selector (Creep选择器)
│   └── Priority Manager (优先级管理器)
└── Execution System (执行系统)
    ├── State Machine (状态机)
    ├── Behavior Engine (行为引擎)
    └── Result Handler (结果处理器)
```

### 2.2 核心组件关系

- **Task Manager**：管理任务生命周期，负责创建、分配、监控任务
- **Task Scheduler**：根据任务需求和creep能力进行智能调度
- **Role Manager**：管理角色定义和能力要求，支持动态角色分配
- **Task Executor**：执行具体任务，使用状态机管理执行过程

## 3. 任务系统设计

### 3.1 任务定义

#### 3.1.1 任务基础结构

每个任务包含以下核心属性：
- **任务ID**：唯一标识符
- **任务类型**：定义任务的基本类别
- **任务参数**：具体执行所需的参数
- **优先级**：任务执行优先级
- **状态**：任务当前执行状态
- **分配信息**：执行该任务的creep信息
- **时间戳**：创建和更新时间

#### 3.1.2 任务类型定义

**基础任务类型**：

这里只是暂时的最基本的定义，可以添加或修改

- **HARVEST**：挖掘任务，从 source 中采集能量，或者从 mineral 或 deposit 中采集资源
- **TRANSPORT**：运输任务，在指定位置、建筑间运输资源，其来源可以是掉落的资源、建筑、某个坐标点(直接丢下，为空则捡起当前所在位置附近的资源)，目标可以是某个坐标点(直接丢下，为空则丢到当前所在位置)、建筑、其他creep
- **BUILD**：建造任务，建造某个建筑
- **REPAIR**：修复任务，修复某个建筑
- **UPGRADE**：升级任务，升级房间控制器
- **ATTACK**：攻击任务，攻击某个敌对目标
- (后续添加其他任务...)

**任务参数设计**：
- **HARVEST任务**：指定 source、mineral、deposit 源ID，可选目标存储ID，目标位置ID或坐标(目标为坐标时，先移动到目标点再丢弃，为空则丢到当前所在位置)
- **TRANSPORT任务**：指定源位置ID或坐标(目标为坐标时，先移动到目标点再尝试捡起目标点周围的资源，为空则捡起当前所在位置附近的资源)、目标位置ID或坐标(目标为坐标时，先移动到目标点再丢弃，为空则丢到当前所在位置)、资源类型
- **BUILD任务**：指定建筑工地ID
- **REPAIR任务**：指定建筑工地ID
- **UPGRADE任务**：指定控制器ID
- **DEFEND任务**：指定敌对目标ID
- (后续添加其他任务...)

### 3.2 任务状态管理

#### 3.2.1 任务生命周期

```
PENDING → ASSIGNED → IN_PROGRESS → PAUSE → COMPLETED/FAILED/CANCELLED
```

- **PENDING**：任务已创建，等待分配
- **ASSIGNED**：任务已分配给creep，等待开始执行
- **IN_PROGRESS**：任务正在执行中
- **PAUSE**：任务暂停执行，creep进入idel，等待继续执行信号
- **COMPLETED**：任务成功完成
- **FAILED**：任务执行失败
- **CANCELLED**：任务被取消

#### 3.2.2 任务内部状态

每个任务执行器内部维护状态机，管理具体的执行步骤：

**HARVEST任务状态**：
- `moving_to_source`：移动到能量源
- `harvesting`：正在采集
- `moving_to_target`：移动到存储目标
- `transferring`：正在转移资源
- `dropping`：将资源放在地上

**TRANSPORT任务状态**：
- `moving_to_source`：移动到源位置
- `withdrawing`：正在提取资源
- `moving_to_target`：移动到目标位置
- `transferring`：正在转移资源
- `dropping`：将资源放在地上

(其他任务也是使用相同方式进行状态设计)

### 3.3 任务管理器设计

#### 3.3.1 核心功能

**任务创建**：
- 根据房间状态自动生成任务
- 支持手动创建特定任务
- 任务参数验证和默认值设置

**任务分配**：
- 根据任务类型和creep能力进行匹配
- 考虑距离、效率、优先级、能力匹配度等因素
- 支持任务抢占和重新分配

**任务监控**：
- 实时监控任务执行状态
- 处理任务超时和失败情况
- 生成任务执行统计信息

#### 3.3.2 任务队列管理

使用优先级队列管理待分配的任务：
- 高优先级任务优先分配
- 支持任务优先级动态调整
- 防止任务饥饿现象

## 4. 角色系统设计

### 4.1 角色定义

#### 4.1.1 角色能力要求

每个角色定义明确的能力要求：

- **harvester**：需要WORK、MOVE、CARRY部件
- **transporter**：需要MOVE、CARRY部件
- **builder**：需要WORK、MOVE、CARRY部件
- **upgrader**：需要WORK、MOVE、CARRY部件
- **defender**：需要ATTACK、MOVE、TOUGH部件
- (其他角色定义...)

#### 4.1.2 角色任务映射

每个角色可以执行的任务不与角色强制关联，角色可以按照需求被分配符合能力的任务，比如harvester的能力有WORK、MOVE、CARRY，那么它也可以执行transporter的任务。
但每个角色都有一个主要任务，角色应该以自身主要任务为最优先，每个角色的主要任务类型定义为：

- **harvester**：HARVEST任务
- **transporter**：TRANSPORT任务
- **builder**：BUILD任务
- **upgrader**：UPGRADE任务
- **defender**：DEFEND任务
- (其他角色定义...)

### 4.2 动态角色分配

#### 4.2.1 能力检测(可能需要进一步完善)

系统自动检测creep的能力组合：
- 分析creep的body部件
- 计算各类型部件的数量
- 生成能力配置方案

#### 4.2.2 角色匹配

根据creep能力匹配可用角色：
- 检查是否满足角色最低要求
- 计算角色适配度评分
- 生成可用角色列表

#### 4.2.3 动态角色调整

根据当前任务动态调整creep角色：
- 任务分配时确定最优角色
- 任务完成后重新评估角色
- 支持角色间的动态切换

## 5. 调度系统设计

### 5.1 任务调度器

#### 5.1.1 调度策略

**基于能力匹配度的调度**：
- 根据任务类型筛选有能力的creep
- 考虑creep当前状态和负载
- 优先选择效率最高的creep

**基于优先级的调度**：
- 高优先级任务优先分配
- 紧急任务可以抢占低优先级任务
- 支持任务优先级动态调整

**基于距离的调度**：
- 计算creep到任务目标的距离
- 优先选择距离最近的creep
- 考虑路径规划和障碍物

#### 5.1.2 调度算法

**多因素评分算法(可能需要进一步完善)**：
- 能力匹配度（权重40%）
- 距离因素（权重30%）
- 当前负载（权重20%）
- 历史效率（权重10%）

**负载均衡**：
- 避免单个creep负载过重
- 分散任务到多个creep
- 监控系统整体负载情况

### 5.2 Creep选择器

#### 5.2.1 选择策略

**能力匹配**：
- 检查creep是否具备执行任务的能力
- 验证角色与任务的兼容性
- 考虑creep的特殊能力

**状态检查**：
- 检查creep是否空闲
- 验证creep健康状况
- 确认creep可以接受新任务

**效率评估**：
- 分析creep的工作效率(执行工作机能的组件，比如WORK、ATTACK、CLAIM等)
- 考虑creep的移动速度
- 评估creep的存储容量

#### 5.2.2 选择优化

**缓存机制**：
- 缓存creep能力信息
- 缓存距离计算大致结果(因为creep的位置有可能发生变化，所以结果不一定完全精确)
- 减少重复计算开销

**批量处理**：
- 批量评估多个creep
- 并行计算评分
- 提高选择效率

## 6. 执行系统设计

### 6.1 任务执行器

#### 6.1.1 执行器基类

定义任务执行器的通用接口：
- 任务验证方法
- 执行状态管理
- 错误处理机制
- 结果报告接口

#### 6.1.2 具体执行器

**HARVEST执行器**：
- 移动到指定能量源
- 执行采集操作
- 处理资源存储
- 管理采集状态

**TRANSPORT执行器**：
- 从源位置提取资源
- 移动到目标位置
- 转移资源到目标
- 处理运输异常

**BUILD执行器**：
- 移动到建筑工地
- 执行建造操作
- 处理材料需求
- 管理建造进度

(其他执行器实现...)

### 6.2 状态机管理

#### 6.2.1 状态转换

每个任务执行器维护内部状态机：
- 定义状态转换规则
- 处理状态转换条件
- 管理状态持久化

#### 6.2.2 状态恢复

支持任务执行中断和恢复：
- 保存执行状态到内存
- 重启时恢复执行状态
- 处理状态不一致情况

### 6.3 结果处理

#### 6.3.1 成功处理

任务成功完成时的处理：
- 更新任务状态为完成
- 释放creep资源
- 生成完成报告
- 触发后续任务

#### 6.3.2 失败处理

任务执行失败时的处理：
- 分析失败原因
- 决定重试或放弃
- 更新任务状态
- 通知调度器

## 7. 系统集成设计

### 7.1 与现有系统集成

#### 7.1.1 渐进式迁移

**阶段1：并行运行**
- 保持现有行为系统运行
- 新任务系统并行运行
- 通过配置控制使用哪个系统

**阶段2：逐步替换**
- 先实现简单的运输任务
- 逐步扩展到其他任务类型
- 最终完全替换硬编码行为

**阶段3：完全迁移**
- 移除旧的行为系统
- 优化新系统性能
- 完善监控和调试功能

#### 7.1.2 兼容性保证

**接口兼容**：
- 提供适配器层
- 逐步迁移，确保平滑过渡

### 7.2 性能优化(后续实现)

#### 7.2.1 CPU优化

**缓存策略**：
- 缓存creep能力信息
- 缓存距离计算结果
- 缓存任务分配结果

**批量处理**：
- 批量更新任务状态
- 批量分配任务
- 减少单次计算开销

**算法优化**：
- 使用高效的数据结构
- 优化搜索算法
- 减少不必要的计算

#### 7.2.2 内存优化(后续实现)

**内存管理**：
- 及时清理完成的任务
- 压缩内存数据结构
- 避免内存泄漏

**数据压缩**：
- 压缩任务参数
- 优化状态存储
- 减少内存占用

## 8. 扩展性设计(后续实现)

### 8.1 新任务类型扩展

#### 8.1.1 扩展流程

**定义新任务类型**：
- 在TaskType枚举中添加新类型
- 定义任务参数接口
- 实现任务验证逻辑

**实现任务执行器**：
- 继承BaseTaskExecutor基类
- 实现具体的执行逻辑
- 定义状态转换规则

**注册到系统**：
- 在TaskManager中注册新任务类型
- 更新角色任务映射
- 添加相应的调度逻辑

#### 8.1.2 扩展示例

先开发基础角色功能，后续再考虑扩展其他角色功能。

#### 8.2.2 动态角色支持

**能力检测扩展**：
- 支持新的部件类型
- 扩展能力计算逻辑
- 优化角色匹配算法

**角色切换优化**：
- 优化角色切换逻辑
- 减少切换开销
- 提高切换效率

## 9. 监控和调试

目前只需要最基本的监控功能，但需要提前留出后续扩展的空间。

### 9.1 系统监控

#### 9.1.1 性能监控

**CPU使用监控**：
- 监控各组件CPU使用情况
- 识别性能瓶颈
- 优化热点代码

**内存使用监控**：
- 监控内存分配情况
- 检测内存泄漏
- 优化内存使用

**任务执行监控**：
- 监控任务执行时间
- 统计任务成功率
- 分析任务失败原因

#### 9.1.2 状态监控

**任务状态监控**：
- 实时监控任务状态
- 检测任务卡死情况
- 生成任务执行报告

**Creep状态监控**：
- 监控creep任务分配
- 跟踪creep执行效率
- 分析creep行为模式

## 10. 性能优化和风险缓解策略

### 10.1 CPU优化策略

#### 10.1.1 缓存机制
- **Creep能力缓存**：每个tick只计算一次creep能力，缓存到内存中
- **距离计算缓存**：使用曼哈顿距离代替精确路径计算，缓存结果
- **任务匹配缓存**：缓存任务与creep的匹配结果

#### 10.1.2 批量处理
- **批量任务分配**：一次处理多个任务，减少循环次数
- **批量状态更新**：批量更新任务和creep状态
- **智能更新频率**：根据系统负载调整更新频率

#### 10.1.3 算法优化
```typescript
// 优化前：O(n*m) 复杂度
for (const task of tasks) {
  for (const creep of creeps) {
    if (canExecuteTask(creep, task)) {
      // 分配任务
    }
  }
}

// 优化后：使用索引和预过滤
const availableCreeps = creeps.filter(c => c.isIdle());
const matchingTasks = tasks.filter(t => t.priority > threshold);
// 使用更高效的匹配算法
```

### 10.2 内存优化策略

#### 10.2.1 数据结构优化
- **压缩任务参数**：使用数字ID代替字符串
- **清理过期数据**：定期清理完成的任务和死亡creep的数据
- **分页存储**：将大量任务数据分页存储

#### 10.2.2 内存监控
```typescript
// 添加内存使用监控
const memoryUsage = {
  tasks: Object.keys(Memory.tasks || {}).length,
  creepStates: Object.keys(Memory.creepStates || {}).length,
  totalSize: JSON.stringify(Memory).length
};
```

### 10.3 风险缓解策略

#### 10.3.1 渐进式实现
1. **最小可行产品**：先实现简单的HARVEST和TRANSPORT任务
2. **A/B测试**：同时运行新旧系统，对比效果
3. **回滚机制**：保留旧系统作为备份

#### 10.3.2 错误处理
```typescript
// 任务执行失败时的降级策略
private handleTaskFailure(task: Task, error: any): void {
  // 1. 记录失败原因
  this.logTaskFailure(task, error);

  // 2. 尝试重新分配
  if (task.retryCount < MAX_RETRY_COUNT) {
    task.retryCount++;
    task.status = 'pending';
    this.taskQueue.push(task);
  } else {
    // 3. 降级到旧系统
    this.fallbackToOldSystem(task);
  }
}
```

#### 10.3.3 监控和告警
- **任务执行时间监控**：超过阈值的任务触发告警
- **CPU使用率监控**：超过80%时启用节能模式
- **内存使用监控**：超过限制时清理缓存

### 10.4 实施建议

#### 10.4.1 优先级排序
1. **高优先级**：实现基础任务系统（HARVEST、TRANSPORT）
2. **中优先级**：实现调度算法和优先级管理
3. **低优先级**：实现高级功能（任务抢占、动态角色切换）

#### 10.4.2 测试策略
- **单元测试**：为每个任务执行器编写测试
- **集成测试**：测试任务调度和分配逻辑
- **性能测试**：在大型房间中测试CPU和内存使用

#### 10.4.3 部署策略
1. **先在测试房间部署**
2. **逐步扩展到其他房间**
3. **监控系统性能指标**
4. **根据反馈调整参数**

### 10.5 预期收益

#### 10.5.1 短期收益
- **代码可维护性提升**：去除硬编码逻辑
- **功能扩展性增强**：新增任务类型更容易
- **调试效率提高**：问题定位更精确

#### 10.5.2 长期收益
- **系统智能化**：基于能力的动态分配
- **资源利用优化**：更高效的creep使用
- **扩展性增强**：支持更复杂的游戏策略

### 10.6 风险评估

#### 10.6.1 高风险因素
- **CPU使用增加**：可能影响游戏性能
- **复杂性增加**：调试和维护难度提升
- **迁移风险**：从现有系统迁移可能引入bug

#### 10.6.2 缓解措施
- **性能基准测试**：在实施前进行性能测试
- **分阶段实施**：降低单次变更的风险
- **完善监控**：及时发现和解决问题

## 结论

基于任务驱动的重构方案在技术上是可行的，但需要谨慎实施。建议：

1. **先实现MVP**：从最简单的任务开始
2. **重视性能**：将性能优化作为核心考虑
3. **完善监控**：建立完善的监控和调试体系
4. **渐进实施**：采用分阶段实施策略，降低风险

这个重构方案将显著提升系统的灵活性和可维护性，但需要在性能和复杂性之间找到平衡点。
